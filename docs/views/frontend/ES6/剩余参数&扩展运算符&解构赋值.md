## Rest参数(剩余参数)
- **函数声明时使用**：剩余参数语法允许我们将一个不定数量的参数表示为一个数组。
- **与解构赋值组合使用**：用于接收剩余的值,存储在数组中。
```js
function introduce (firstName, lastName, ...detail) {
  console.log(firstName + ' ' + lastName); // J K
  console.log(detail[0])  // 19
}
introduce("J", "K", 19, "man")
```
**注意：Rest 参数必须放到参数列表的末尾** 
```js
// 错误
function fn(a, ...rest, b) {}  // Rest parameter must be last formal parameter
```
### 关于arguments
- arguments可以获取全部参数，是类数组。
- 想截取入参的一部分，或者使用数组的特性时，最好使用rest，而非arguments。
```js 
// MDN剩余参数实例
// Before rest parameters, "arguments" could be converted to a normal array using:
function f(a, b) {
  var normalArray = Array.prototype.slice.call(arguments);
  // -- or --
  var normalArray = [].slice.call(arguments);
  // -- or --
  var normalArray = Array.from(arguments);

  var first = normalArray.shift(); // OK, gives the first argument
  var first = arguments.shift(); // ERROR (arguments is not a normal array)
}

// Now we can easily gain access to a normal array using a rest parameter
function f(...args) {
  var normalArray = args;
  var first = normalArray.shift(); // OK, gives the first argument
}
```
- 箭头函数是没有arguments的(箭头函数也没有this)
```js
// 如果我们在箭头函数中访问 arguments，访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```
### 解构剩余参数
## Spread语法(展开语法)
它看起来和 rest 参数很像，也使用 ...，但是二者的用途完全相反。
当在函数调用中使用 ...arr 时，它会把可迭代对象 arr “展开”到参数列表中。
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

console.log( Math.max(1, ...arr1, 2, ...arr2, 25) )
```
### 构造字面量数组,字面量对象
构造字面量对象（ECMAScript 2018规范新增特性）:其行为是, 将已有对象的所有可枚举(enumerable)属性拷贝到新构造的对象中。
```js
let parts = ['shoulders', 'knees'];
let lyrics = ['head', ...parts, 'and', 'toes']; 

let obj = {name: 'Joe', age: 10}
let objClone = { ...obj };
```
Spread 语法内部使用了迭代器来收集元素，与 for..of 的方式相同。
**在数组或函数参数中使用展开语法时，只能用于可迭代对象**(可以使用for...of)
因此，对于一个字符串，for..of 会逐个返回该字符串中的字符，...str 也同理会得到 "H","e","l","l","o" 这样的结果。随后，字符列表被传递给数组初始化器 [...str]。
```js
let str = "Hello!"
console.log([...str])  
``` 
也可以使用Array.from
```js
let str = "Hello!"
Array.from(str)
```
**Array.from**返回一个新的，浅拷贝的数组实例
对于将一些“东西”转换为数组的任务，Array.from 往往更通用。
- Array.from 适用于类数组对象也适用于可迭代对象。
- Spread语法只适用于可迭代对象
Object没有实现迭代器接口，可以直观的理解，毕竟对象是没有顺序的
```js
var obj = {'key1': 'value1'};
var array = [...obj]; // TypeError: obj is not iterable
```
### 在函数调用时使用展开语法，等价于apply的方式。
```js
function myFunction(x, y, z) { }
var args = [0, 1, 2];
myFunction.apply(null, args);
// -- or --
myFunction(...args)
```
### 在new表达式中应用
使用 new 关键字来调用构造函数时，不能直接使用数组+ apply 的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]）。有了展开语法, 将数组展开为构造函数的参数就很简单了
```js
var dateFields = [1970, 0, 1]; // 1970年1月1日
var d = new Date(...dateFields);
```
### 获取一个array/object的副本（浅拷贝）
```js
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 将数组 spread 到参数列表中,然后将结果放到一个新数组
// 两个数组中的内容相同吗？
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true
// 两个数组相等吗？
alert(arr === arrCopy); // false（它们的引用是不同的）
// 修改我们初始的数组不会修改副本：
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3

//Object也是一样的 
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; 
// 两个对象中的内容相同吗？
console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true
// 两个对象相等吗？
console.log(obj === objCopy); // false (not same reference)
// 修改我们初始的对象不会修改副本：
obj.d = 4;
console.log(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
console.log(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```
Object.assign
```js
let user = {name: "Joe", age: 19}
let clone = {}
for(let key in user) {
  clone[key] = user[key]
}
clone.name = "Pete" // 改变了其中的数据
user.name // Joe
```
可以用Object.assign来代替for in来进行浅拷贝
`Object.assign(dest, [src1, src2, src3...])`  
- dest是目标对象，
- 如果被拷贝的属性的属性名已经存在，那么它会被覆盖

## 解构赋值
- **左边的永远指代的是声明的变量名**
- 等号右侧可以是任何可迭代对象
```js
// 1 
let [firstName, surname] = "Ilya Kantor".split(' ');
// 2
let [one, two, three] = new Set([1, 2, 3]);
// 3
let user = new Map();
user.set("name", "John");
user.set("age", "30");
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
```
交换变量
```js
let guest = "Jane";
let admin = "Pete";
[guest, admin] = [admin, guest];
```
收集剩余元素
```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
rest // ["Consul", "of the Roman Republic"]
```
默认值及赋值
```js
let user = {
  name: "John",
  years: 30
};

let {name, years: age, isAdmin = false} = user;
```
### 对象的解构赋值
```js
let options = {
  title: "Menu",
  height: 200
};

let {width: w = 100, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```
剩余模式
```js
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = 名为 title 的属性
// rest = 存有剩余属性的对象
let {title, ...rest} = options;

// 现在 title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
```
关于：Rest element must be last element
展开运算符只能出现在解构赋值中的末尾，如果允许在中间，js是没办法计算区间位置的。
```js
const obj = { a:1, c:3 }
const newObj = { a:1, ...obj, b:2}

const {a, ...rest, b } = { a: 1, b: 2}
//Uncaught SyntaxError: Rest element must be last element

const {a, b, ...rest} = { a:1, c:2, d:3, b:2 }  //rest {c:2,d:3}
```


## 遍历器（Iterator）
就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
原生具备 Iterator 接口的数据结构：
- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象
