# 类型
- Undefined
- Null
- Number
- String
- Boolean
- Symbol(ES6引入)
- Object：基于Object还实现了其他常用对象子类，如Array,Function,Date,Error,RegExp


## toString 最精准的类型判断
Object类型的每个实例都有toString()方法，返回对象的字符串表示，所以每个实例化的对象都可以调用toString()方法。
如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。
事实上，其他类型都或多或少重写了toString()方法，导致不同类型的对象调用toString()方法产生返回值各不相同。

### 如何直接使用Object.prototype.toString
```js
//不通过原型链查找,正确直接使用方式
Object.prototype.toString.call/apply(obj)  //'[object Object]'

//虽然输出一样，但这是因为Object.prototype也是对象
Object.prototype.toString() //'[object Object]'
```
数组对象通过this绑定调用Array.prototype.toString()方法，返回数组值的字符串拼接，但是非数组对象通过this绑定调用Array.prototype.toString()方法，返回的是该对象的字符串表示，另外null和undefined不可以通过绑定调用Array.prototype.toString()方法。
```js
var array = [1, 's', true, {a: 2}];
array.toString();//"1,s,true,[object Object]"
Array.prototype.toString.call(array);//"1,s,true,[object Object]"

Array.prototype.toString.call({});   //"[object Object]"
Array.prototype.toString.call(1)   //"[object Number]"
```
除了Object和Array两种情况，其他类型都不支持非自身实例通过this绑定调用该Object子类原型对象上的toString()方法，这说明它们在重写toString()方法时，明确限定了调用该方法的对象类型，非自身对象实例不可调用。所以，一般我们只使用Object.prototype.toString.call/apply()方法。

### 类型检查
```js
Object.prototype.toString.call({});   //"[object Object]"
Object.prototype.toString.call([]);   //"[object Array]"
Object.prototype.toString.call(function(){});   //"[object Function]"
Object.prototype.toString.call('');   //"[object String]"
Object.prototype.toString.call(1);   //"[object Number]"
Object.prototype.toString.call(true);   //"[object Boolean]"
Object.prototype.toString.call(null);   //"[object Null]"
Object.prototype.toString.call(undefined);  //"[object Undefined]"
Object.prototype.toString.call();  //"[object Undefined]"
Object.prototype.toString.call(new Date());  //"[object Date]"
Object.prototype.toString.call(/at/);   //"[object RegExp]"
(function(){
    Object.prototype.toString.call(arguments);  //[object Arguments]
})()
Object.prototype.toString.call(document);  //[object HTMLDocument]
```
### 其他对象重写
- **null和undefined**
没有相应的构造函数，所以它们没有也无法调用toString()方法，也就是说它们不能访问任何属性和方法，只是基本类型而已。

- **基本包装类型（Boolean/Number/String类）**
**为什么基本类型也可以调用toString呢？**
由于String基本包装类型的存在，在必要的时候JS引擎会把字符串字面量转换成一个String对象，从而可以执行访问属性和方法的操作
（1）创建一个String类型的实例；
（2）在实例上调用指定的方法；
（3）销毁这个实例。
```js
var strObject = new String('wangpf');
strObject.toString(); //'wangpf'
strObject = null;
```
`注意`：上述代码是JS引擎自动执行的，你无法访问strObject对象，它只存在于代码的执行瞬间，然后立即销毁，所以我们无法再运行时给基本类型添加属性和方法，除非直接通过new显示调用基本包装类型创建对象，但是不建议

string VS stringObject
```js
var str = 'I am a string';
typeof str; //"string"
str instanceof String; //false

var strObject = new String('I am a string');
typeof strObject; //"object"
strObject instanceof String; //true
strObject instanceof Object; //true
```
**什么时候会触发自动调用呢？**
使用操作符的时候，如果其中一边为对象，则会先调用toSting方法，也就是隐式转换，然后再进行操作。

- **其他**
```js
// String
var str = "a";
str.toString(); //"a"
String.prototype.toString.call(str); //"a"

// Number
var num = 520;
num.toString(); //"520"
Number.prototype.toString.call(num); //"520"

// Boolean
var boo = true;
boo.toString(); //"true"
Boolean.prototype.toString.call(boo); //"true"

// Date
var date = new Date();
date.toString();
//"Fri May 11 2018 14:55:43 GMT+0800 (中国标准时间)"
Date.prototype.toString.call(date);
//"Fri May 11 2018 14:55:43 GMT+0800 (中国标准时间)"

// RegExp
var re = /cat/g;
re.toString();// "/cat/g"
RegExp.prototype.toString.call(re);// "/cat/g"

// 另外：直接调用toString()应该就是变相的undefined.toString()方法
Object.prototype.toString.call();  //"[object Undefined]"
```
用toString.call/apply(this)去代替Object.prototype.toString.call/apply(this)使用，是不严谨的，容易导致一些问题，比如当我们自定义了toString()方法时，直接调用toString()方法，就不会再默认调用Object类的toString()方法，而是会使用我们自定义的方法，这样可能得不到我们想要的结果，所以我们还是应当尽量使用Object.prototype.toString.call/apply(this)。



## typeof 
在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。因为 typeof null 结果为 "object"。
```js
typeof 1 === 'number' // true
typeof Infinity === 'number'; // true
typeof NaN === 'number'; // true, 尽管它是 "Not-A-Number" (非数值) 的缩写

typeof '123' === 'string' // true
typeof (typeof 1) === 'string'; // typeof 总是返回一个字符串
typeof String(1) === 'string'; // String 将任意值转换为字符串，比 toString 更安全

typeof null === 'object' // true，注意 null 不是对象，这里是特殊的。

typeof [1, 2, 4] === 'object'; // true

typeof true === 'boolean' // true
typeof function a() {} === 'function'
typeof Symbol(2) === 'symbol'
typeof undefined === 'undefined'

//使用new操作符
// 除 Function 外的所有构造函数的类型都是 'object'
typeof new Number(100) === 'object'
typeof new String('123') === 'object'
typeof new Date() === 'object'
var func = new Function();
typeof func === 'function'

//NaN
typeof Number("123z") === "number" // 123z 在转数字的是时候遇到z出错就是NaN了。NaN为number类型
typeof 1/0; //NaN（这个NaN不是字符串类型，是数值类型）
typeof (typeof 1/0) === 'number'; //NaN（这个NaN不是字符串类型，是数值类型）
```
## instanceof
instanceof 只能用来判断引用数据类型，基本数据类型不可以。
缺点是原型链指向改动的话，这个的判断就可能会出错。在存在多个全局作用域的情况下无法得到准确的结果。
eg: var isArray = value instanceof Array;
返回TRUE的前提是 value是一个数组，并且该变量要和Array构造函数在同一个全局作用域中；不然若是value在其他的frame框架中定义的数组，上述代码就会返回false。
检测对象是原生对象还是开发人员自定义对象时也会有不可靠情况发生。

## 作用域安全的构造函数
Object.prototype.toString方法不能检测非原生构造函数的构造函数名。所以如果用它检测自定义的构造函数会返回[object Object]
```js
function Person(name, age) {
    console.log('this', this)
    this.name = name
    this.age = age
}

let p1 = new Person('p1',11)
let p2 = Person('p2',12)  //相当于函数调用，此时构造函数Person内的this会指向window

// 解决办法：用instanceof创建一个作用域安全的构造函数
function Person(name, age) {
    if (this instanceof Person) {
        this.name = name
        this.age = age
    } else {
        return new Person(name, age)
    }
}
```

(由Object.prototype.toString.call( )引发关于toString( )方法的思考)[https://juejin.cn/post/6844903604990509063]
[typeof、instanceof、Object.prototype.toString](https://juejin.cn/post/6949005060705779720#heading-0)
[浅谈 instanceof 和 typeof 的实现原理](https://juejin.cn/post/6844903613584654344)
[判断是否是数字](https://zhuanlan.zhihu.com/p/267990898)